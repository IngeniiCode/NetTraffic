# other variables (no not edit unless you know what you are doing)
my $out;
my $file;
my $filter;
my $filter_c;
my $print_help;
my $ether;
my $ip,
my $trans;
my $err;
my $packets;
my $index;
my $dump_nr;
my $only_syn = 1;
my $all;
my $i = 0;
my $s_index = 1;

# check if we are showing all packets
$only_syn = 0 if ( $all );

# reset the index value
$index = 1;

# start reading the file
$packets = Net::Pcap::open_offline( $file, \$err );
if( defined $err )
{
	die 'Unable to read the PCAP file ' . $err . "\n";
}


# now we need to check if we are going to read all packets or dump a certain traffic
if( defined $dump_nr )
{
	# dump a certain traffic

	# first check if out file is defined
	die( 'Unable to determine output file, use the parameter -w FILE' ) unless defined $out;

	# try to open the out file (create a new one)
	if( -e $out )
	{
		print "Overwriting file: $out\n";
	}
	open( OF, '>' . $out );

	binmode( OF );

	# now to dump a certain stream
	dump_stream( $dump_nr );
# =============================
#  Define  Package Variables
# =============================

	close( OF );
# =============================
#  Define  Package Methods
# =============================

# + + + + + + + + + + + + + + + + + + + +
# +  --   C O N S T R U C T O R     --  +
# + + + + + + + + + + + + + + + + + + + +
sub new {
        my ($class,$args) = @_;  # ingest package name, and any args
        my $self  = { 
		filter_str => $args->{filter} || 'tcp',  # set the default filter value	
		conv_index => 0,  #  protocol conversations index
	};
	return bless ($self, $class); # this is what makes a reference into an object
}
else
{
	# normal run, print all the packets

	# check if there is a filter defined
	$s_index = 0 if defined $filter;	# if we have a filter defined, then we cannot show the index value (in this version)
	$filter = 'tcp' unless defined $filter;

# +
# +  set the fitler object will use to decode pcap
# +
sub set_filter {
	my($self,$filter_str) = @_;

	if( ! $s_index )
	{
		print STDERR 'Using PCAP filter.  Please be aware that in this version of pcapcat, there isn\'t support for index and dumping data while using predefined filters', "\n";
		print STDERR 'Please use the tool without custom filters to get the index variable printed out, for use with -d to dump data',"\n";
	}
	# create the filter
	Net::Pcap::compile( $packets, \$filter_c, $filter, 1, undef );
	Net::Pcap::setfilter( $packets, $filter_c );

	# read all the packets
	Net::Pcap::loop( $packets, -1, \&read_all_packets, '' ); 
	
	# close the network file (since we have finished our processing)
	Net::Pcap::close( $packets );
	return $self->{filter_str} = $filter_str;
}

#########################################################################################################
#		routines
#########################################################################################################

# 	dump_stream
# this function takes as a parameter an index into the pcap file and reads all packets that belong
# to that particular stream
sub dump_stream
{
	my $in = shift;
	my %header;
	my $packet;

	if( $only_syn )
	{
		$filter = 'tcp[13] & 0x3f = 0x02';
	}
	else
	{
		# the filter we are looking for is just defined as a TCP
		$filter = 'tcp';

	}
		
	Net::Pcap::compile( $packets, \$filter_c, $filter, 1, undef );
	Net::Pcap::setfilter( $packets, $filter_c );
		
	# find the correct packet
	for( my $i=0; $i < $in; $i++ )
	{
		$packet = Net::Pcap::next( $packets, \%header );
	}
# +
# + Open connections to pcap file and start iterating on sections
# +
# +    UDP traffic is checked first to create the internal DNS
# +    cache.
# +
# +    TCP traffic looking for all the other exiting bits of 
# +    information, datagrams, telegrams, miligrams and gram crackers
# +
sub process_file {
	my($self,$infile) = @_;

	# strip header information and get the data part
	$ether = NetPacket::Ethernet->decode( $packet );	
	$ip = NetPacket::IP->decode( $ether->{'data'} );
	$trans = NetPacket::TCP->decode( $ip->{'data'} );
	# Wipe clean the oject's cache
	$self->{C} = undef;  # totaly destroy the cache.

	# now I need to read all the data part of the entire conversation 
	# and dump it into a file
	# construct a filter
	$filter = 'tcp and (host ' . $ip->{'src_ip'} . ' and host ' . $ip->{'dest_ip'} . ') and ( port ' . $trans->{'dest_port'} . ' and port ' . $trans->{'src_port'} . ')';
	Net::Pcap::compile( $packets, \$filter_c, $filter,1,undef);
	Net::Pcap::setfilter( $packets, $filter_c );
	# Init Pcap handle
	printf("Use pcap file %s\n",$infile);
	$self->_init_pcap($infile || $self->{infile});  # not required to set if already set

	# read all the packets that belong to this particular stream
	Net::Pcap::loop( $packets, -1, \&dump_to_file, '' );
	
	return 1;
}
	# COLLECT THE UDP PACKETS
	$self->process_udp();

#	dump_to_file
#
# A small function which reads packets created in the dump_stream function
# and prints them to a file, an output file, to contain the information
# found inside streams
sub dump_to_file
{
	my $user_data = shift;
	my $header = shift;
	my $pack = shift;

	# strip headers	
	$ether = NetPacket::Ethernet->decode( $pack );	
	$ip = NetPacket::IP->decode( $ether->{'data'} );
	$trans = NetPacket::TCP->decode( $ip->{'data'} );

	# and now to dump the content of the data variable into a file
	print OF $trans->{'data'};

	return 1;
}

sub read_all_packets
{
	my $user_data = shift;
	my $header = shift;
	my $pack = shift;
	my $fcheck;
	my $input;

	# check if we have printed $buffer
	if( $i == $buffer )
	{
		# print out a statement
		print "Read more packets [Y|n]: ";
		$input = <STDIN>;
		chomp( $input );

		if( lc( $input ) eq 'n' )
		{
			# we quit
			print "Not printing out more packets\n";
			exit 0;	
		}	
		else
		{
			# we continue
			$i = 0;
			# clear the screen
			system $^O eq 'MSWin32' ? 'cls' : 'clear';

		}	
	}
	# COLLECT THE TCP PACKETS
#	$self->process_tcp();

	# strip header information
	$ether = NetPacket::Ethernet->decode( $pack );	
	
	# check if IP
#	if( $ether->{type} eq 2048 )
#	{
		$ip = NetPacket::IP->decode( $ether->{'data'} );

		# check if TCP or UDP
		if( $ip->{'proto'} eq 6 )
		{
			# TCP
			$trans = NetPacket::TCP->decode( $ip->{'data'} );

			# check if we are to dump "all" traffic or just show new connections
			if( $only_syn )
			{
				# we don't care about ECN bits
				$fcheck = $trans->{'flags'} & 0x3f;

				# check if we have a SYN packet
				if( $fcheck == 0x02  )
				{
					print '[',$index,'] ' if $s_index;
					
					print 'TCP ' , $ip->{'src_ip'}  , ':' , $trans->{'src_port'} ,  ' -> ' , $ip->{'dest_ip'} , ':' , $trans->{'dest_port'},"\n";
					# increment both the index variable as well as the (for printing)
					$index++;
					$i++;
				}
			}
			else
			{	
				# we show all connections
				print '[',$index,'] ' if $s_index; 
				print 'TCP ', $ip->{'src_ip'}  . ':' . $trans->{'src_port'} .  ' -> ' . $ip->{'dest_ip'} . ':' . $trans->{'dest_port'},'[',$trans->{'flags'},"]\n";
				# increment both the index variable as well as the (for printing)
				$index++;
				$i++;
			}

	
		}
#		In this version we do not care about packets that are not TCP
#		elsif( $ip->{'proto'} eq 17 )
#		{
#			# UDP
#			$trans = NetPacket::UDP->decode( $ip->{'data'} );
#			print 'UDP ' . $ip->{'src_ip'}  . ':' . $trans->{'src_port'} .  ' -> ' . $ip->{'dest_ip'} . ':' . $trans->{'dest_port'} . "\n";
#		}
#		else
#		{
#			print 'Not TCP nor UDP, perhaps ICMP? Protocol number is: ' . $ip->{'proto'} . "\n";
#		}

#	}
#	else
#	{
#		print 'Packet is not an IP packet, rather a ' . $ether->{type} . "\n";
#	}
}
	# close the network file (since we have finished our processing)
	Net::Pcap::close( $self->{PCAP} );

# a simple sub routine to show 
sub show_version
{
	print $0,' version ',$version, ' ',"\n";
	exit 0;
	return;
}

0;

__END__

=pod

=head1 NAME

B<pcapcat> - a simple script to read PCAP file and dump the content of the conversation into a file 

=head1 SYNOPSIS 

B<pcapcat> [-f|--filter PCAP FILTER] -r|--read PCAP_FILE [-a|-all]

B<pcapcat> -w|--write OUTPUTFILE [-a|--all] -d|-dump INDEX

B<pcapcat>[ -v|--version] [-h|--help|-?] 

=head1 OPTIONS
# +
# +  initialize the pcap handle, with passed infile name.
# +  function force overrides the any setting in $self->{infile} 
# +
sub _init_pcap {
	my($self,$infile) = @_;
	# -- beware of locals
	my $err;

=over 8
	# set infile if exists
	die(sprintf("Unable to locate and/or open pcap input file '%s'\n",$infile)) unless -e $infile;  

=item B<-f|-filter PCAP_FILTER>
	# start reading the file
	if($self->{PCAP} = Net::Pcap::open_offline( $infile, \$err )){

Enter a traditional PCAP filter to filter out the content of the file (see man tcpdump for further details about constructing such a filter)
		# save file for reference
		$self->{infile} = $infile;

=item B<-r|-read PCAP_FILE>
		return  $infile;
	}

The PCAP file that the script should read
	return undef;  # this failed.
}

=item B<-a|-all>

The default behaviour of the script is to only show TCP SYN packets, that is to show entire conversations.  To override this option and provide the possibility to
dump an already started conversation use this option.
# +
# +   UDP Packet Processing
# +
sub process_udp {
	my($self) = @_;
	# -- beware of locals
	my $filter_c;  # holder for compiled filter
	
	# create the filter
	Net::Pcap::compile( $self->{PCAP}, \$filter_c, 'udp', 1, undef );
	Net::Pcap::setfilter( $self->{PCAP}, $filter_c );

=item B<-w|-write FILE>
	# read all the packets
	Net::Pcap::loop( $self->{PCAP}, -1, \&_proc_udp, $self );  # self is passed as user data

Use this option to define an output file to dump the content of the TCP stream into.  If the option -d or -dump is used, then this option has to be defined.
	return;
}

=item B<-d|-dump INDEX>

The default behaviour (if the -d option is not used) is to dump information about TCP connections found inside the pcap file.  In the printout an index number is written.
To be able to dump the content of a stream into a file you must first find out the index number and then use the -d INDEX option with that index number to dump that conversation
into a file.
# +
# +   TCP Packet Processing
# +
sub process_tcp {
	my($self) = @_;
	# -- beware of locals
	my $filter_c;  # holder for compiled filter

=item B<-v|-version>
	# create the filter
	Net::Pcap::compile( $self->{PCAP}, \$filter_c, 'tcp', 1, undef );
	Net::Pcap::setfilter( $self->{PCAP}, $filter_c );

Dump the version number of the script to the screen and quit
	# read all the packets
	Net::Pcap::loop( $self->{PCAP}, -1, \&read_all_packets, '' ); 
	
	return;
}

=item B<-h|-help|-?>
	
# + + + + + + + + + + + + + + + + + + + +
# +  --   S E M I - P R I V A T E   --  +
# + + + + + + + + + + + + + + + + + + + +

# +
# +  process the UDP Packets
# +
sub _proc_udp {
	my ($self,$header,$pack) = @_;
	# -- beware of locals
        my $fcheck;
        my $input;

	# printf("SELF: %s\n",Dumper $self);
	# printf("PCAP: %s\n",Dumper $self->{PCAP});

	return;
}

Print this help menu
1; 

=back

